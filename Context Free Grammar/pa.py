#
#  Automata Programming Assignment #2
#
#  Name: 박성준 
#  ID: 20205075
#

import sys
import copy
# Do not import any other libraries


def is_variable(value):
    """
    Upper case letters are variables.
    :param value: Node value.
    :return: True or False.
    """
    return value.isupper()


def is_terminal(value):
    """
    Lower case letters are terminal symbols.
    :param value: Node Value.
    :return: True or False.
    """
    return value.islower()


class DerivationTree:
    def __init__(self, value, children=[]):
        """
        :param root_value: Root value of derivation tree. An English letter, upper case or lower case.
        :param children: A list of child nodes of root.
        """
        self.value = value
        self.children = children

    def print_tree(self, height=[]):
        """
        Do not modify this function!
        Just use it when you want to print out the tree.
        """
        height_level = len(height)
        tab_str = "|  "
        branch = "".join(map(lambda x: tab_str if x else "   ", height[:-1]))
        branch += "+--" if height_level > 0 else ""

        print(branch, self.value, sep='')
        for i, child in enumerate(self.children):
            isterminal = i == len(self.children) - 1
            child.print_tree([*height, not isterminal])

    def string(self):
        """
        :return: String made of terminal nodes of derivation tree.
        """
        d = ""
        if len(self.children) == 0:
            return self.value
        else:
            for child in self.children:
                d += child.string()
        return d

    def length(self):
        """
        :return: Length of terminal nodes of derivation tree (not variables).
        """
        length = 0
        for letter in self.string():
            length += int(is_terminal(letter))
        return length

class CFG:
    def __init__(self, filename):
        # Production rules are stored in dictionary form.
        self.rules = {}
        with open(filename, "r") as fp1:
            lines = fp1.readlines()
            for line in lines:
                content = line.split()
                left = content[0]
                for right in content[1:]:
                    if right == '|' or right == '>':
                        continue
                    if self.rules.get(left) is None:
                        self.rules[left] = {right}

                    else:
                        self.rules[left].add(right)

    def make_child(self, tree):
        """
        :param tree: Derivation tree.
        :return l: list of derivation trees after only one leftmost variable production
        :return done: just check you have done production, necessary for recursion
                    if you don't use it, erase it. 
        """
        # Write your code here. e.g.
        I = []
        done = False
        
        if len(tree.children) == 0: # mean no child node
            if tree.value in self.rules:
                sub_I = []
                for rule in self.rules[tree.value]:
                    tmpsub = copy.deepcopy(tree)
                    tmpsub.children = [DerivationTree(a) for a in rule]
                    sub_I.append(tmpsub)
                return sub_I, True
        
            else:
                return [], False
                
        else: # mean have child
            for i, child in enumerate(tree.children):
                sub_I, done = self.make_child(child)
                if done:
                    for sub_tree in sub_I:
                        tmp = copy.deepcopy(tree)
                        tmp.children[i] = sub_tree
                        I.append(tmp)
                    break
            return I, done
     
    def make_string(self, l = 0):
        """
        :param l: length of string.
        :return: List of tree with string length l that can be generated by CFG
        """
        # Write your code here. e.g.
        # return l
        OLD = []
        NEW = []
        
        def tree_list(tree, length, depth): # tree: DerivationTree Type
            '''
            print("Depth - " + "**" * depth)
            print(tree.string())
            '''
            if len(tree.string()) == tree.length() == length:
                OLD.append(tree.string())
            else:
                if tree.length() < length: # there is no unit transition
                    add_trees, _ = self.make_child(tree)
                    for add_tree in add_trees:
                        if add_tree.length() <= length:
                            tree_list(add_tree, length, depth + 1)
                        else:
                            pass #invalid
                else:
                    pass
        
        for start_variable in list(self.rules.keys()):
            tree_list(DerivationTree(start_variable), l, 0)
        
        for string in OLD:
            if string not in NEW:
                NEW.append(string)
                
        return NEW

    def ambiguous_checker(self):
        """
        Just check the ambiguity only for strings of length 10 or less.
        :return: True if ambiguous. False if not ambiguous.
        """
        # Write your code here. e.g.
        # ambiguous = True
        # return ambiguous
        OLD = []
        NEW = []
        ambiguous = False
        
        def tree_list(tree, length, depth): # tree: DerivationTree Type
            if len(tree.string()) == tree.length():
                OLD.append(tree.string())
            else:
                if tree.length() < length: # there is no unit transition
                    add_trees, _ = self.make_child(tree)
                    for add_tree in add_trees:
                        if add_tree.length() <= length:
                            tree_list(add_tree, length, depth + 1)
                        else:
                            pass #invalid
                else:
                    pass
        
        for start_variable in list(self.rules.keys()):
            tree_list(DerivationTree(start_variable), 10, 0)
        
        # print(OLD)
        
        for string in OLD:
            if string not in NEW:
                NEW.append(string)
            else:
                ambiguous = True
                return ambiguous
        
        return ambiguous


def test(*args):
    """
    If you want to debug your code, use the test function.
    This confirms only one case, so even if you pass the test function, you may not get a perfect score.
    """
    if len(args) < 2:
        raise ValueError("Not enough arguments")

    filename = args[1]

    # Test for string and length in DerivationTree
    a = DerivationTree('a')
    b = DerivationTree('b')
    AA = DerivationTree('A')
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    B.children = [b]
    A.children = [AA, a]
    S.children = [A, B]
    if S.string() != "Aab":
        raise ValueError("Incorrect string function")
    else:
        print("Success String")
    if S.length() != 2:
        raise ValueError("Incorrect length function")
    else:
        print("Success Length")

    # Test for make_child in CFG
    Q = CFG(filename)
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    S.children = [A, B]
    tree_list, _ = Q.make_child(S)
    str_list = []
    for tree in tree_list:
        str_list.append(tree.string())
    str_list.sort()
    
    if str_list != ["AaB", "aB"] and str_list != ["Ab"]:
        raise ValueError("Incorrect make_child function")
    else:
        print("Success make_child")

    # Test for make_string in CFG
    make_list = Q.make_string(4)
    if len(make_list) != 2:
        raise ValueError("Incorrect make_string function")
    else:
        print("Success make_string")

    # Test for ambiguous_checker in CFG
    if not Q.ambiguous_checker():
        raise ValueError("Incorrect ambiguous_checker function")
    else:
        print("Success ambiguous_checker")

if __name__ == '__main__':
    args = sys.argv
    test(*args)